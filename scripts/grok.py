# grok_api.py

import os
from dotenv import load_dotenv
import openai
import json
import re

# Load environment variables and initialize API key and base URL
def initialize_grok_api():
    """
    Initialize environment variables and set up the OpenAI API key and base URL for GROK.
    """
    # Load environment variables from .env file
    load_dotenv()

    # Access the OpenAI API key from environment
    api_key = os.getenv("XAI_API_KEY")
    if not api_key:
        raise ValueError("API key not found. Please set 'XAI_API_KEY' in your .env file.")

    # Set OpenAI API key and base URL
    openai.api_key = api_key
    client = openai.OpenAI(api_key=api_key)
    client.base_url = "https://api.x.ai/v1"

    return client

# Function to get completion from the GROK model
def get_grok_completion(client, message):
    """
    Sends a chat completion request to the GROK model with the provided message.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    message (str): The user's input message for the GROK API.
    
    Returns:
    dict: The JSON response from the GROK model.
    """
    model = "grok-beta"
    try:
        completion = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": message}]
        )
        return completion.model_dump_json(indent=2)
    except Exception as e:
        print(f"An error occurred: {e}")
        return None
    
def extract_grok_content(response_json):
    """
    Extracts and returns the message content from the GROK completion response JSON.
    
    Parameters:
    response_json (str): JSON response string from the GROK API.
    
    Returns:
    str: The content of the message from the GROK response.
    """
    try:
        data = json.loads(response_json)
        message_content = data["choices"][0]["message"]["content"]
        return message_content
    except (json.JSONDecodeError, KeyError, IndexError) as e:
        print(f"Error parsing response: {e}")
        return None

def generate_summary(client, transcription, formatted_duration, num_speakers, language):
    """
    Generates a summary of the conversation transcription based on the metadata and transcription provided.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    transcription (str): The text transcription of the audio.
    formatted_duration (str): The length of the audio in hours and minutes (e.g., '1h 20m').
    num_speakers (int): The number of distinct speakers.
    language (str): The language of the conversation.
    
    Returns:
    string: The response from the GROK model containing the summary.
    """
    # Define the prompt structure
    prompt_intro = """Summarize this conversation or talk transcription, focusing on the main ideas, topics discussed, and any conclusions or next steps presented. Provide additional context about the conversation using the metadata of the audio file:

- Include the length of the audio, formatted in hours and minutes (e.g., 1h 20m).
- Specify the number of distinct speakers involved.
- Indicate the language in which the conversation took place.

Present the summary in a concise and easy-to-read format. The summary must be in the same language as the conversation transcription (the one specified in the metadata).

"""
    # Construct the metadata prompt
    prompt_metadata = f"""Audio Metadata:

Duration: {formatted_duration}
Number of speakers: {num_speakers}
Language: {language}

Transcription:

"""
    # Combine the full message for the GROK model
    message = prompt_intro + prompt_metadata + transcription

    # Call the completion function and parse the result
    response_json = get_grok_completion(client, message)
    if response_json:
        return extract_grok_content(response_json)
    return None

def generate_RAG_initial_message(client, summary):
    """
    Generates a first message for the chat RAG functionality.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    summary (str): The summary of the text transcription of the audio, previously generated by Grok.
    
    Returns:
    string: The response from the GROK model containing the summary.
    """
    # Define the prompt structure
    prompt_intro = """You are a RAG system chatbot that can search through transcribed audio/video data. Your goal is to generate a first message in the transcription language to introduce yourself to the user and to briefly explain your functionalities. This is the summary of the transcription you can search through:
    
    """
    # Combine the full message for the GROK model
    message = prompt_intro + summary

    # Call the completion function and parse the result
    response_json = get_grok_completion(client, message)
    if response_json:
        return extract_grok_content(response_json)
    return None

def generate_RAG_initial_message_2(client, summary):
    """
    Generates a first message for the chat RAG functionality.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    summary (str): The summary of the text transcription of the audio, previously generated by Grok.
    
    Returns:
    string: The response from the GROK model containing the summary.
    """
    # Define the prompt structure
    prompt_intro = """You are a RAG system chatbot capable of searching through transcribed audio and video data to provide relevant information. Your task is to craft an engaging first message in the transcription language, introducing yourself to the user and offering a brief overview of your main features. Here is a summary of the transcribed content available for you to search through:

"""
    # Combine the full message for the GROK model
    message = prompt_intro + summary

    # Call the completion function and parse the result
    response_json = get_grok_completion(client, message)
    if response_json:
        return extract_grok_content(response_json)
    return None

def generate_RAG_phrases(client, user_question, summary, chunk):
    """
    Generates a phrase or several phrases to vectorize and laters use for RAG search.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    user_question (str): The actual question from the user.
    summary (str): The summary of the text transcription of the audio, previously generated by Grok.
    chunk (str): A chunk example of the conversation/talk.
    
    Returns:
    string: The response from the GROK model containing the summary.
    """
    # Define the prompt structure
    prompt_intro = """You are a RAG system chatbot responsible for transforming user questions into concise, neutral phrases that closely resemble the language and tone of the transcribed data. Your task is to output a JSON structure containing one or more sentences that match the length and neutrality of typical statements in the transcription. Avoid adding assumptions, personal opinions, or extra context not directly requested by the user.

Each phrase should:

1. Remain concise—aim for a length similar to short, informative statements.
2. Be neutral in tone—avoid implied opinions or subjective language.
3. Mirror the style of typical statements from the transcription summary.

### Summary of the transcribed data ###

"""

    chunk_sample_intro = """

### Here is a sample of what the conversation looks like, for you to have an idea of the phrases or keywords you need to generate ###
 
"""

    user_question_intro = """

###Here is the question of the user ###
 
"""
    # Combine the full message for the GROK model
    message = prompt_intro + summary + chunk_sample_intro + chunk + user_question_intro + user_question

    # Call the completion function and parse the result
    response_json = get_grok_completion(client, message)
    if response_json:
        return extract_grok_content(response_json)
    return None

def respond_RAG_question(client, user_question, chunk_list):
    """
    Generates a first message for the chat RAG functionality.
    
    Parameters:
    client (openai.OpenAI): Initialized OpenAI client with base URL and API key.
    user_question (str): The actual question from the user.
    chunk_list (set): A list of the chunks that matched with the question.
    
    Returns:
    string: The response from the GROK model containing the summary.
    """
    # Define the prompt structure
    prompt_intro = """You are a RAG system chatbot tasked with answering a user’s question by analyzing and synthesizing information from several chunks of transcribed audio or video data. Each chunk contains relevant portions of the transcription. Use the chunks provided to create a clear and concise answer to the user’s question.

### Instructions ###
- Combine Information Across Chunks: Review each chunk and integrate relevant details to provide a comprehensive response. Avoid repeating information unless necessary for clarity.
- Remain Neutral: Answer factually and objectively, without adding assumptions or opinions that aren’t explicitly in the provided chunks.
- Be Concise: Aim for a clear and direct answer. Avoid overly long responses, focusing only on key information that directly addresses the user’s question.
- Stay in Context: If the user’s question is broad, include relevant context from the chunks. If the question is specific, focus on directly answering it with pertinent details only.

### Provided Chunks ###

"""

    user_question_intro = """

### User Question ###

"""
    # Combine the full message for the GROK model
    if len(chunk_list) == 0:
        message = "Inform the user that the question was not found, and prompt them to ask something else."
    message = prompt_intro + "\n\n".join(chunk_list) + user_question_intro + user_question

    # Call the completion function and parse the result
    response_json = get_grok_completion(client, message)
    if response_json:
        return extract_grok_content(response_json)
    return None

import json
import re

def extract_phrases_from_json(json_string):
    """
    Extracts the list of phrases from a JSON structure embedded in a string,
    allowing for cases where there are code block markers and a different key name.
    
    Parameters:
    json_string (str): A string containing a JSON structure with "phrases" key.
    
    Returns:
    list: A list of phrases extracted from the JSON structure.
    """
    # Remove markdown code block markers
    json_string = re.sub(r'```(?:json)?\s*|\s*```', '', json_string)

    # Find the JSON part in the string using regex
    json_match = re.search(r'\{.*\}', json_string, re.DOTALL)
    
    if json_match:
        json_data = json_match.group(0)
        try:
            parsed_data = json.loads(json_data)
            # Use "phrases" key instead of "converted_phrases"
            return parsed_data.get("phrases", [])
        except json.JSONDecodeError:
            return []
    else:
        return []
